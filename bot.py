'''
# bot.py
# bot server back end and front end for interaction with
# server.
# date: 6/23/21
# author: dnglokpor
'''

# imports
import discord, os, sys                   # environment
import time                               # timer
from dotenv import load_dotenv            # sensitive data cache
import logging                            # logging util
from discord.ext import commands as com   # discord lib
import discord.ext.commands.errors as err # errors
import random as rnd                      # randomizer
try:
    import cPickle as pickle              # pickle
except ModuleNotFoundError:
    import pickle

# add game world modules to path
sys.path.insert(0, "D:/myLewysG/Logiciels/Mes Tests/IdleFantasyHub/world")

# game world package imports
from world.classes import Adventurer, Fighter, Ranger, \
   Elementalist

# bot config
load_dotenv()        # loads .env data
# attach bot commands prefixes
PREFIXES = ['>', '/', ';' ]
bot = com.Bot(command_prefix = PREFIXES)
# logging
REPORT_DIR = "logs" # path to log file
REPORT_FILE = "eventLog.txt" # log file
   
# helpers
def senderInfo(ctx: com.Context):
   '''uses the context to return the channel and mention
   of author of the message received.'''
   return (ctx.message.channel, ctx.message.author.mention)
def boolEvaluate(string: str):
   '''return a boolean value that matches the passed
   string. defaults to false.'''
   if string.lower() == "true":
      return True
   else:
      return False

def getReportFile():
   '''concatenates and return the report file path.'''
   return REPORT_DIR + '\\'+ REPORT_FILE

def eReport(report):
   '''uses the logging module to quickly save the report 
   in a file''' 
   # dir doesn't exist
   if not os.path.isdir(REPORT_DIR):
      os.mkdir(REPORT_DIR) # create the folder   
   
   # config logger
   fm = 'a'       # appending by default
   if not os.path.exists(getReportFile()): # file doesn't exist
      fm = "w+"   # then create and append
   logging.basicConfig(filename = getReportFile(),
      format = "%(asctime)s %(process)d %(message)s",
      datefmt = "%d-%b-%y %H:%M:%S", filemode = fm
   )
                        
   # making log object
   logger = logging.getLogger()
   logger.setLevel(logging.DEBUG)
   logger.propagate = False
   
   # log the report
   logger.info(report)

def logError(eData):
   '''logs an error that occured at runtime. "eData" must
   be the tuple generated by sys.exc_info().'''
   eData
   eString = eData[0] + '\n' + eData[1]
   print(eString)    # console print it
   eReport(eString)  # report log it 
   # print trace to report file
   print(eData[2], file = getReportFile())

# back end
# records
USER_RECORDS_PATH = "records/users"
HERO_SAVES_PATH = "records/saves"

# IdleUser object
class IdleUser:
   '''this class records information about the users that
   interact with the bot so they can be remembered.
   provides a way to write this info to the disc.'''
   def __init__(self, id: int, uname: str):
      '''only requires those to create the object. other
      attributes will be set later.'''
      self.id = id
      self.uname = uname
      self.hero = None
      self.inCity = True
      self.available = True
      self.topFloor = 0
   
   # getters
   def getUname(self) -> str:
      return self.uname
   def getID(self) -> int:
      return self.id
   def hasHero(self) -> bool:
      return self.hero != None
   def getHero(self) -> Adventurer:
      return self.hero
   def isInCity(self) -> bool:
      '''True if self.inCity evaluates to True.'''
      return self.inCity == True
   def isAvailable(self) -> bool:
      '''True if self.available evaluates to True.'''
      return self.available == True
   def getTopFloor(self) -> int:
      return self.topFloor
      
   # setters: most attributes can be used directly
   def setHero(self, adv: Adventurer):
      '''set the hero attribute to the Adventurer object
      it represents.'''
      self.hero = adv
   
   # toString
   def __str__(self) -> str:
      '''creates a string that describe the object.'''
      descr = "Idle Fantasy User:\n"
      descr += "id {}\n".format(self.id)
      descr += "username {}\n".format(self.uname)
      descr += "hero {}\n".format(self.hasHero())
      descr += "city {}\n".format(self.inCity)
      descr += "available {}\n".format(self.available)
      descr += "top {}\n".format(self.topFloor)
      return descr
   
# records helpers
def save(user: IdleUser):
   '''write the user object to a file in a readable way.
   overwrite the file if it already exists.'''
   # create the file
   userfile = USER_RECORDS_PATH + '/' + str(user.id) + '.usr'
   herofile = HERO_SAVES_PATH + '/' + str(user.uname) + '.her'
   # write user info to a file
   with open(userfile, "w+") as record:
      record.write(user.__str__())
   # write avatar to file
   if user.hasHero(): # an avatar is tied to this account
      with open(herofile, "wb") as save:
         pickle.dump(user.hero, save, pickle.HIGHEST_PROTOCOL)
   return True      

# load user data
def load(id: int, uname: str) -> IdleUser:
   '''looks for the user save file and create a user object
   that matches it and return it. if the hero value is True,
   look for the hero save file, loads it and add it to the
   user item. return said item. this assumes the user file
   exists already.'''
   userfile = USER_RECORDS_PATH + '/' + str(id) + '.usr'
   herofile = HERO_SAVES_PATH + '/' + str(uname) + '.her'
   # recover user file contents
   with open(userfile, "r") as record:
      contents = record.read()
   lines = contents.split('\n')
   lines = lines[3:] # delete title line through id line
   # recreate user object
   user = IdleUser(id, uname)
   # hero
   if boolEvaluate(lines[0].split()[1]): # there is a hero
      with open(herofile, "rb") as save:
         user.hero = pickle.load(save)
   else:
      user.hero = None
   # other
   user.inCity = boolEvaluate(lines[1].split()[1])
   user.available = boolEvaluate(lines[2].split()[1])
   user.topFloor = int(lines[3].split()[1])
   return user
   
# finds if a user is a registered user
def isRegistered(id: int) -> bool:
   '''checks if the passed id is associated with an
   existing user record file.'''
   userfile = USER_RECORDS_PATH + '/' + str(id) + '.usr'
   return os.path.isfile(userfile)

# terminates if not (registered w/ hero)
async def isRegisteredWithHero(ctx):
   '''checks for registration and hero. if either is missing
   an error message is sent to the command author.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   valid = True
   if not isRegistered(id):
      valid = False
      await waitThenSend(ctx, nRegMSG.format(mention))
   elif not load(id, username).hasHero():
      valid = False
      await waitThenSend(ctx, nHeroMSG.format(mention))
   return valid

@bot.event
async def on_ready():
   readyMSG = "We have logged in as {}\n".format(bot.user)
   print(readyMSG)
   # get all guilds
   readyMSG += "online in servers:\n"
   for g in bot.guilds:
      readyMSG += "{}\t".format(g)
   eReport(readyMSG)
   

# command errors
@bot.event
async def on_command_error(ctx: com.Context, exception):
   '''deal with errors at bot commands execution for
   a smooth runtime.'''
   # DEBUG BLOC
   print(type(exception))
   print(exception)
   # END OF DEBUG BLOC
   channel, mention = senderInfo(ctx)
   if type(exception) == err.CommandNotFound:
      await waitThenSend(ctx,
         "{}, that command doesn't exist. Use `help` to see"
         " all available commands.".format(mention)
      )
   elif type(exception) == err.MissingRequiredArgument:
      command = ctx.command
      msg = "{} you forgot to specify ".format(mention)
      if(command.name == "hero"):
         msg += "the hero class you want to use.\n"
         msg += "`eg: >hero Fighter`"
      else:
         pass
      await waitThenSend(ctx, msg)
   else: # unknow error
      server = ctx.guild
      triggerUser = ctx.me
      triggerCom = ctx.command
      eReport("error on {} by {} on server {}".format(
         triggerCom, triggerUser, server)) # log trigger info
      eReport(str(type(exception)))
      eReport(str(exception))
      await waitThenSend(ctx, 
         "Something went wrong. Sorry, try something else.", 2)

# front end
def buildResponse(ctx: com.Context) -> str:
   '''creates a reply to a hello command by mentionning
   the sender and in a randomly selected formula return
   it to the caller.'''
   hellos = ["Hi", "Oh hello there", "Hiya", "What's up",
      "What's cooking", "Ohayo"
   ]
   return " ".join([rnd.choice(hellos), '{}.'])
   
async def waitThenSend(ctx: com.Context, message: str,
   wait = 1):
   '''sends the passed "message" to the specified channel
   after waiting "wait" seconds.'''
   time.sleep(wait)
   await ctx.send(message)
      
@bot.command(name = "hello",
   help = "Says hello to the username, using a randomly choosed formula.")
async def hello(ctx):
   '''Says Hi to the username.'''
   channel, mention = senderInfo(ctx)
   await waitThenSend(ctx, buildResponse(ctx).format(mention))


# premade messages
nRegMSG = "You are not registered {}. "\
   "Use the `guild` command to register first."
nHeroMSG = "You don't have a hero {}. use the `hero` "\
   "command to register a hero to your account."
tips = [
   "Use the `status` command to get the status of your hero.",
   "Use the `bag` command to display the contents of your "
   "bag.",
   "Use the `explore` command to send your hero on a dungeon "
   "exploration. during exploration, you will be considered "
   "**not in the city** and **not available**.",
]


# register player
@bot.command(name = "guild", help = "register the user as a "
   "potential player of the game by recording their id and "
   "username. then display the instructions for them to pick "
   "their hero.")
async def guild(ctx):
   '''record user if they are not recorded yet. give instructions
   on how to select a hero.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   if isRegistered(id): # user already exists
      msg = "{} you are already registered. ".format(mention)
      msg += "Use the `help` command to see what commands"\
      " are available to you."
      await waitThenSend(ctx, msg)
   else: # new user
      # register them
      newUser = IdleUser(id, username)
      save(newUser)
      # reply to them
      msg = "Welcome to the Idle Guild {}. We are so happy to "\
      "have you with us. Without further ado, let's register "\
      "you as an adventurer. "\
      "We do need to know what class of adventurer you are. "\
      "We know of three possible classes: **Fighter**, "\
      "**Ranger** and **Elementalist**. Use the `hero` "\
      "command to specify your class.\n"
      "`eg: >hero Fighter`"
      await waitThenSend(ctx, msg.format(mention))

# add a hero to player account
@bot.command(name = "hero", help = "allows a user to add a "
   "hero to their account. heroes are necessary to be able "
   "to explore the dungeon, or interact with city facilities.\n"
   "possible choices: **Fighter**, **Ranger**, **Elementalist**.\n"
   "`eg: ;hero Fighter`.")
async def hero(ctx, className: str):
   '''loads a registered user's profile and if they don't 
   yet have a hero.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   if not isRegistered(id):
      msg = nRegMSG.format(mention)
   elif load(id, username).hasHero():
      msg = "You already have a hero {}. ".format(mention)
      msg += "Everyone only gets one. Don't be greedy."
   else: # registered user w/ no hero
      user = load(id, username)
      msg = "Congratulations {}. ".format(mention)
      if className.lower() == "fighter":
         user.setHero(Fighter(username))
         msg += "You are now a Fighter.\n"
      elif className.lower() == "ranger":
         user.setHero(Ranger(username))
         msg += "You are now a Ranger.\n"
      elif className.lower() == "elementalist":
         user.setHero(Elementalist(username))
         msg += "You are now an Elementalist.\n"
      else:
         await waitThenSend(ctx, 
            "**{}** is not a know hero class.".format(className))
      msg += user.hero.__str__(False) + '\n'
      msg += tips[0] + '\n' + tips[1] + '\n' + tips[2] + '\n'
      save(user)
   await waitThenSend(ctx, msg)

# display player account info
@bot.command(name = "profile", help = "prints an account of the "
   "user summary.")
async def profile(ctx):
   '''prints the user's account summary.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   profile = str()
   if isRegistered(id): # user already exists
      user = load(id, username)
      profile = "**{}** [*id {}*]\n".format(user.uname, user.id)
      if user.hasHero():
         profile += "class <"
         profile += user.getHero().getClassName() + '>\n'
      else:
         profile += "No registered hero.\n"
      profile += "Top explored floor: {}\n".format(user.topFloor)
      if user.isInCity():
         profile += "Currently in the City.\n"
      else:
         profile += "Currently in exploration\n"
      if user.isAvailable():
         profile += "Available.\n"
      else:
         profile += "Not available\n"
   else: # user is not registered
      profile = nRegMSG.format(mention)
   await waitThenSend(ctx, profile)

# display avatar infos
@bot.command(name = "status", help = "displays the whole status "
   "of your hero. Useful to check overall stats, skills and "
   "equipment.")
async def status(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      status = user.getHero().__str__(False)
      await waitThenSend(ctx, status)

# display avatar inventory
@bot.command(name = "bag", help = "list down the contents of "
   "your bag if there is any contents.")
async def bag(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      bag = user.getHero().getBag().__str__()
      await waitThenSend(ctx, bag)

# shows learnable skills
@bot.command(name = "learnable", help = "shows you the all the "
   "skills that can be learned by your hero.")
async def learnable(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      mastery = user.getHero().getMastery().__str__(False)
      await waitThenSend(ctx, mastery)

# shows learned skills
@bot.command(name = "learned", help = "shows you the all the "
   "skills your hero has learned.")
async def learned(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      mastered = user.getHero().getMastery().getUnlocked(
         user.getHero().getLevel().getCurrent())
      msg = "Learned skills:\n"
      for skill in mastered:
         msg += skill.__str__() + '\n'
      await waitThenSend(ctx, msg)

# run module
if __name__ == "__main__":
   # bot runs in try catch to control execution
   try:
      bot.run(os.getenv("BOT_TOKEN"))
   except: # catch any occurence
      logError(sys.exc_info())