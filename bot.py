'''
# bot.py
# bot server back end and front end for interaction with
# server.
# date: 6/23/21
# author: dnglokpor
'''

# imports
import discord, os, sys                   # environment
import time as tm                         # timer
from dotenv import load_dotenv            # sensitive data cache
import logging                            # logging util
from discord.ext import commands as com   # discord lib
import discord.ext.commands.errors as err # errors
import random as rnd                      # randomizer
try:
   import cPickle as pickle               # pickle
except ModuleNotFoundError:
   import pickle

# add game world package to path so that internal imports work
sys.path.insert(0, 
   "D:/myLewysG/Logiciels/Mes Tests/IdleFantasyHub/world")
# add pictures generation package to path
sys.path.insert(0, 
   "D:/myLewysG/Logiciels/Mes Tests/IdleFantasyHub")

# game world package imports
from idleUser import IdleUser, save, load, USER_PICS_PATH,\
   USER_RECORDS_PATH, USER_TEMPS_PATH
from picsGen import genProfile, genBag
from world.helpers import timeString
from world.classes import Fighter, Ranger, Elementalist
from world.confrontation import Party
from world.dungeon import DUNGEON

# bot config
load_dotenv()        # loads .env data
# attach bot commands prefixes
PREFIXES = ['>', '/', ';' ]
bot = com.Bot(command_prefix = PREFIXES)
# logging
REPORT_DIR = "logs" # path to log file
REPORT_FILE = "eventLog.txt" # log file
   
# helpers
def senderInfo(ctx: com.Context):
   '''uses the context to return the channel and mention
   of author of the message received.'''
   return (ctx.message.channel, ctx.message.author.mention)

def getReportFile():
   '''concatenates and return the report file path.'''
   return REPORT_DIR + '\\'+ REPORT_FILE

def eReport(report):
   '''uses the logging module to quickly save the report 
   in a file''' 
   # dir doesn't exist
   if not os.path.isdir(REPORT_DIR):
      os.mkdir(REPORT_DIR) # create the folder   
   
   # config logger
   fm = 'a'       # appending by default
   if not os.path.exists(getReportFile()): # file doesn't exist
      fm = "w+"   # then create and append
   logging.basicConfig(filename = getReportFile(),
      format = "%(asctime)s %(process)d %(message)s",
      datefmt = "%d-%b-%y %H:%M:%S", filemode = fm
   )
                        
   # making log object
   logger = logging.getLogger()
   logger.setLevel(logging.DEBUG)
   logger.propagate = False
   
   # log the report
   logger.info(report)

def logError(eData):
   '''logs an error that occured at runtime. "eData" must
   be the tuple generated by sys.exc_info().'''
   eData
   eString = eData[0] + '\n' + eData[1]
   print(eString)    # console print it
   eReport(eString)  # report log it 
   # print trace to report file
   print(eData[2], file = getReportFile())

# back end
# finds if a user is a registered user
def isRegistered(id: int) -> bool:
   '''checks if the passed id is associated with an
   existing user record file.'''
   userfile = USER_RECORDS_PATH + '/' + str(id) + '.usr'
   return os.path.isfile(userfile)

# terminates if not (registered w/ hero)
async def isRegisteredWithHero(ctx):
   '''checks for registration and hero. if either is missing
   an error message is sent to the command author.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   valid = True
   if not isRegistered(id):
      valid = False
      await waitThenSend(ctx, nRegMSG.format(mention))
   else: # they are registered so we check for hero
      with open(USER_RECORDS_PATH + str(id) + ".usr", 'r') as record:
         valid = ((((record.read()).split('\n'))[3]).split())[1]
      valid = valid == "True"
      if not valid:
         await waitThenSend(ctx, nHeroMSG.format(mention))
   return valid

# rescue algorithm
async def rescueFallen(key: int, floor: int) -> list:
   '''rescue a fallen adventurer/party if they were defeated
   on the floor the player is exploring. return a list
   representing things recovered from the fallen as reward.
   if no reward was found, return '''
   temp = USER_TEMPS_PATH + str(key) + ".resq"
   rewards = None
   if os.path.isfile(temp): # fallen party exist
      with open(temp, 'r') as file:
         data = pickle.load(file) # recover data
         if data["floor"] == floor:
            rewards = list()
            for fallen in data["users"]:
               # possible reward from fallen
               bag = fallen.getHero().getBag()
               if not bag.isEmpty():
                  stack = rnd.choice(list(bag.values()))
                  rewards.append((stack[0], len(stack)))
               # free user
               fUser = load(fallen.getID(), fallen.getUname())
               fUser.inCity = True
               fUser.setKey(0) # reset exploration key
               save(fUser)
               # tell fallen user he was rescued
               dm = await getDM(fUser)
               dm.send("`you have been rescued. please be careful "
                  "next time.`")
   return rewards

@bot.event
async def on_ready():
   readyMSG = "We have logged in as {}\n".format(bot.user)
   print(readyMSG)
   # get all guilds
   readyMSG += "online in servers:\n"
   for g in bot.guilds:
      readyMSG += "{}\t".format(g)
   eReport(readyMSG)
   

# command errors
# @bot.event
async def on_command_error(ctx: com.Context, exception):
   '''deal with errors at bot commands execution for
   a smooth runtime.'''
   # DEBUG BLOC
   print(type(exception.original))
   print(exception.original)
   # END OF DEBUG BLOC
   channel, mention = senderInfo(ctx)
   command = ctx.command
   if type(exception) == err.CommandNotFound:
      await waitThenSend(ctx,
         "{}, that command doesn't exist. Use `help` to see"
         " all available commands.".format(mention)
      )
   elif type(exception) == err.MissingRequiredArgument:
      msg = "{} you forgot to specify ".format(mention)
      if command.name == "hero":
         msg += "the hero class you want to use.\n"
         msg += "`eg: >hero Fighter`"
      elif  command.name == "scout":
         msg += "the floor which info you seek.\n"
         msg += "`eg: >scout 1`"
      else:
         msg = "a required argument.\n"
         msg += "use `>help {}".format(command.name)
         msg += "` to see the correct use."
      await waitThenSend(ctx, msg)
   elif type(exception) == err.BadArgument:
      msg = "use `>help {}".format(command.name)
      msg += "` to see the correct use."
      await waitThenSend(ctx, msg)
   else: # unknow error
      server = ctx.guild
      triggerUser = ctx.me
      triggerCom = ctx.command
      eReport("error on {} by {} on server {}".format(
         triggerCom, triggerUser, server)) # log trigger info
      eReport(str(type(exception.__cause__)))
      eReport(str(exception.__cause__))
      await waitThenSend(ctx, 
         "Something went wrong. Sorry, try something else.", 2)

# front end
def buildResponse(ctx: com.Context) -> str:
   '''creates a reply to a hello command by mentionning
   the sender and in a randomly selected formula return
   it to the caller.'''
   hellos = ["Hi", "Oh hello there", "Hiya", "What's up",
      "What's cooking", "Ohayo"
   ]
   return " ".join([rnd.choice(hellos), '{}.'])

# delayed response
async def waitThenSend(ctx: com.Context, message: str,
   wait = 1):
   '''sends the passed "message" to the specified channel
   after waiting "wait" seconds.'''
   tm.sleep(wait)
   await ctx.send(message)

# recover user client
async def getDiscordUser(id: int):
   '''uses the id of a discord user to recover the
   discord.Client.User object associated with it and return
   it.'''
   uObject = await bot.fetch_user(id)
   return uObject

# find dm channel
async def getDM(user: IdleUser):
   '''retrieve a dm channel from a IdleUser user account.'''
   uObject = await getDiscordUser(user.getID())
   dm_channel = uObject.dm_channel
   if dm_channel == None:
      dm_channel = await uObject.create_dm()
   return dm_channel

@bot.command(name = "hello",
   help = "Says hello to the username, using a randomly choosed formula.")
async def hello(ctx):
   '''Says Hi to the username.'''
   channel, mention = senderInfo(ctx)
   await waitThenSend(ctx, buildResponse(ctx).format(mention))


# premade messages
nRegMSG = "You are not registered {}. "\
   "Use the `guild` command to register first."
nHeroMSG = "You don't have a hero {}. use the `hero` "\
   "command to register a hero to your account."
tips = [
   "Use the `profile` command to get your account status.",
   "Use the `bag` command to display the contents of your "
   "bag.",
   "Use the `explore` command to send your hero on a dungeon "
   "exploration. during exploration, you will be considered "
   "**not in the city**.",
   "Your hero's health **heals by itself** as time goes by.",
   "If you die during an exploration, your hero's party will"
   " be stuck on that floor until someone saves them."
]


# register player
@bot.command(name = "guild", help = "register the user as a "
   "potential player of the game by recording their id and "
   "username. then display the instructions for them to pick "
   "their hero. also record the user profile picture.")
async def guild(ctx):
   '''record user if they are not recorded yet. give instructions
   on how to select a hero.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   if isRegistered(id): # user already exists
      msg = "{} you are already registered. ".format(mention)
      msg += "Use the `help` command to see what commands"\
      " are available to you."
      await waitThenSend(ctx, msg)
   else: # new user
      # register them
      newUser = IdleUser(id, username)
      # record user avatar as picture
      author = ctx.message.author
      avatarAsset = author.avatar_url_as(format = "png")
      userpic = USER_PICS_PATH + str(id) + '.png'
      await avatarAsset.save(userpic)
      newUser.setPic(userpic)
      # save to permanent record
      save(newUser)
      # reply to them
      msg = "Welcome to the Idle Guild {}. We are so happy to "\
      "have you with us. Without further ado, let's register "\
      "you as an adventurer. "\
      "We do need to know what class of adventurer you are. "\
      "There are three possible classes: **Fighter**, "\
      "**Ranger** and **Elementalist**. Use the `hero` "\
      "command to specify your class.\n"
      "`eg: >hero Fighter`"
      await waitThenSend(ctx, msg.format(mention))

# add a hero to player account
@bot.command(name = "hero", help = "allows a user to add a "
   "hero to their account. heroes are necessary to be able "
   "to explore the dungeon, or interact with city facilities.\n"
   "possible choices: **Fighter**, **Ranger**, **Elementalist**.\n"
   "`eg: ;hero Fighter`.")
async def hero(ctx, className: str):
   '''loads a registered user's profile and if they don't 
   yet have a hero.'''
   id = ctx.message.author.id
   username = ctx.message.author.name
   channel, mention = senderInfo(ctx)
   if not isRegistered(id):
      msg = nRegMSG.format(mention)
   elif load(id, username).hasHero():
      msg = "You already have a hero {}. ".format(mention)
      msg += "Everyone only gets one. Don't be greedy."
   else: # registered user w/ no hero
      user = load(id, username)
      msg = "Congratulations {}. ".format(mention)
      token = str()
      done = className.lower() in ["fighter", "ranger", "elementalist"]
      if className.lower() == "fighter":
         user.setHero(Fighter(username))
         msg += "You are now a Fighter"
         token = ":crossed_swords:"
      elif className.lower() == "ranger":
         user.setHero(Ranger(username))
         msg += "You are now a Ranger"
         token = ":bow_and_arrow:"
      elif className.lower() == "elementalist":
         user.setHero(Elementalist(username))
         msg += "You are now an Elementalist"
         token = ":magic_wand:"
      else:
         await waitThenSend(ctx, 
            "**{}** is not a know hero class.".format(className))
      if done:
         msg = token + msg + token + '\n'
         msg += tips[0] + '\n' + tips[1] + '\n' + tips[2] + '\n'
         save(user)
         await waitThenSend(ctx, msg)

# display player account info
@bot.command(name = "profile", help = "show the player's profile "
   "status page.")
async def profile(ctx):
   '''sends a profile status page to the author of the message
   if they are registered players.'''
   if (isRegistered(ctx.message.author.id)):
      user = load(ctx.message.author.id, ctx.message.author.name)
      profile = discord.File(genProfile(user))
      mention = ctx.message.author.mention
      await ctx.send("here is your profile {}:".format(mention), 
         file = profile)
   else:
      await ctx.send(nRegMSG) 

# display avatar inventory
@bot.command(name = "bag", help = "list down the contents of "
   "your bag if there is any contents.")
async def bag(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      bag = discord.File(genBag(user))
      mention = ctx.message.author.mention
      await ctx.send("here's what you own {}:".format(mention), 
         file = bag)
      #bag = user.getHero().getBag().__str__()
      #mention = ctx.message.author.mention
      #bag = mention + "'s " + bag
      #await waitThenSend(ctx, bag)

# shows learnable skills
@bot.command(name = "learnable", help = "shows you the all the "
   "skills that can be learned by your hero.")
async def learnable(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      mastery = user.getHero().getMastery().__str__(False)
      await waitThenSend(ctx, mastery)

# shows learned skills
@bot.command(name = "learned", help = "shows you the all the "
   "skills your hero has learned.")
async def learned(ctx):
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      mastered = user.getHero().getMastery().getUnlocked(
         user.getHero().getLevel().getCurrent())
      msg = "Learned skills:\n"
      for skill in mastered:
         msg += skill.__str__() + '\n'
      await waitThenSend(ctx, msg)

# show floor information
@bot.command(name = "scout", help = "display information on "
   "the specify floor if and only if you have explored it."
   "\neg: `>scout 1`")
async def scout(ctx, floor: int):
   if isRegistered(ctx.message.author.id):
      user = load(ctx.message.author.id, ctx.message.author.name)
      mention = ctx.message.author.mention
      if floor < 1:
         await waitThenSend(ctx, "Invalid floor!!!")
      elif not DUNGEON.__contains__(floor):
         resp = mention
         resp += " , that floor isn't available yet."
         await waitThenSend(ctx, resp)
      else: # we are good
         info = mention
         info += " here is the intelligence on floor {}:\n".format(floor)
         if floor <= user.getTopFloor(): # already explored
            info += DUNGEON[floor].__str__(True)
         else: # never explored
            info += DUNGEON[floor].__str__()
         await waitThenSend(ctx, info)
   else:
      await waitThenSend(ctx, nRegMSG)

# set up user for exploration
def readyUser(user: IdleUser, start: int):
   '''set the appropriate user flags and the key needed
   for the user to be exploration ready.'''
   user.inCity = False
   user.setKey(start)
   save(user)

# explore dungeon
@bot.command(name = "explore", help = "explore the specified "
   "floor of the dungeon. you can specify up to **3** other players "
   "to explore with. just specify their ID in your Friendbook. "
   "separeted by a comma (no spaces allowed). they must be in "
   "your Friendbook to be allowed in your party."
   "\neg.: `;explore 1` or `;explore 1 reac1,bail2,susa3`")
async def explore(ctx, f: int, allies: str=None):
   # in case of empty allies
   if allies == None:
      allies = "" # empty string
   do = False
   start = 0
   if (await isRegisteredWithHero(ctx)): # terminates in case of no hero
      user = load(ctx.message.author.id, ctx.message.author.name)
      mention = ctx.message.author.mention
      if f < 1:
         await waitThenSend(ctx, "Invalid floor!!!")
      elif not DUNGEON.__contains__(f):
         resp = mention
         resp += " , that floor isn't available yet."
         await waitThenSend(ctx, resp)
      elif f > user.getTopFloor() + 1:
         resp = mention
         resp += ", you can't go to that floor yet. you still"
         resp += " need to explore floor {}".format(
            user.getTopFloor() + 1)
         await waitThenSend(ctx, resp)
      else: # floor is in reach
         if not (user.isInCity()):
            resp = mention
            resp += ", you have to be `in town` to go on "
            resp += "exploration."
            await waitThenSend(ctx, resp)
         else: # free and ready to explore
            do = True
            start = int(tm.time()) # timer
            # update user disponibility
            readyUser(user, start)
   if do: # exploration setup block
      going = [user,]
      # add coop heroes
      if allies != "":
         allies = allies.split(',')
         for a in allies:
            friend = user.getFriendbook().getFriend(a)
            if friend != None:
               friend = load(friend[0], friend[1])
               if friend.canCoop():
                  going.append(friend)
                  readyUser(friend, start)
                  party.append(friend.getHero())
                  fMSG = "**{}** invited to explore floor {}.".format(
                     user.getName(), f)
                  fMSG += " use `;report` to check on the status the exploration."
                  dm = await getDM(friend)
                  await dm.send(fMSG)
               else:
                  await waitThenSend(ctx,
                     "{} is not available for coop.".format(
                        friend.getUname()))
            else: # no user of that name in phonebook
               await waitThenSend(ctx,
                  "you don't have a friend by that name!")
      setupData = {
         "startTime": start,
         "floor": f,
         "users": going
      }
      with open(USER_TEMPS_PATH + str(start) + ".wait", "wb") as setupFile:
         pickle.dump(setupData, setupFile, pickle.HIGHEST_PROTOCOL)
      # the rest will be ran by the bg_explorer.py process
      # announce that the party has left
      msg = ""
      for u in going:
         msg += u.getUname()
         if u != going[-1]:
            u += ", "
      msg += " go on an exploration of the {} floor.".format(f)
      msg += " use `;report` to check on the status the exploration."
      await waitThenSend(ctx, msg)

# report command
@bot.command(name = "report", help = "report on the exploration that "
   "the player went on. if exploration isn't over, says how much "
   "time remains.")
async def report(ctx):
   '''report on exploration status.'''
   if (await isRegisteredWithHero(ctx)):
      user = load(ctx.message.author.id, ctx.message.author.name)
      mention = ctx.message.author.mention
      dm_channel = ctx.message.author.dm_channel
      if dm_channel == None:
         dm_channel = await ctx.message.author.create_dm()
      if user.isInCity():
         await waitThenSend(ctx,
            "you didn't go on any exploration {}.".format(mention))
      else: # was on an exploration
         # load temp file
         temp = USER_TEMPS_PATH + str(user.getKey()) + ".done"
         data = None
         with open(temp, 'rb') as expFile:
            data = pickle.load(expFile)
         current = int(tm.time())
         if current < data["endTime"]: # not completed
            remain = timeString(data["endTime"] - current)
            await waitThenSend(ctx,
               "`{}` until end of your exploration {}.".format(remain,
                  mention))
         else: # completed
            # two cases based on data['cleared']
            if data["cleared"]: # success
               for u in data["users"]:
                  u.getHero().resurrect() # resurrect hero if needed
                  # rescue fallen adventurer
                  rewards = await rescueFallen(u.getRescueKey(), 
                     data["floor"])
                  report = data["report"]
                  if rewards != None:
                     report += "rescue rewards: "
                     for i, (itm, q) in enumerate(rewards):
                        u.getHero().getBag().addMulti(itm, q)
                        report += itm.getName() + " x " + str(q)
                        if i < len(rewards) - 1:
                           report += ", "
                  u.setRescueKey(0) # reset rescue key
                  u.inCity = True # set as in town
                  u.setKey(0) # reset exploration key
                  u.setTopFloor(data["floor"]) # update top
                  save(u) # save user account and hero
                  await (await getDM(u)).send(report) # dm
               os.remove(temp) # erase temp file
            else: # failure
               # in case of failure, the player(s) hero(es) is(are) 
               # stuck in the dungeon until rescued.
               # rename ".wait" into a ".resq"
               os.rename(temp, 
                     USER_TEMPS_PATH + str(user.getKey()) + ".resq")
               # send the DMs
               for u in data["users"]:
                  await (await getDM(u)).send(data["report"]) # dm
            # announce to the user(s) to check their DM
            await waitThenSend(ctx, 
                  mention + "check your DMs for the report.")
               
# test command
@bot.command(name = "test", help = "for development purposes.")
async def test(ctx, other = None):
   '''used to try out library methods and other.'''
   await waitThenSend(ctx, 
      "*No beta function available at the moment.*")  

# run module
if __name__ == "__main__":
   # bot runs in try catch to control execution
   try:
      bot.run(os.getenv("BOT_TOKEN"))
   except: # catch any occurence
      logError(sys.exc_info())