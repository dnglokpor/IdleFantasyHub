'''
# bot.py
# bot server back end and front end for interaction with
# server.
# date: 6/23/21
# author: dnglokpor
'''

# import
import discord, os, sys                   # environment
from threading import Thread              # threading
import time                               # timer
from dotenv import load_dotenv            # sensitive data cache
import logging                            # logging util
from discord.ext import commands as com   # discord lib
from asynciofix import asyncio_run        # async processes
import random as rnd                      # randomizer

# bot config
load_dotenv()        # loads .env data
# attach bot commands prefixes
PREFIXES = ['do>', 'do$', ';' ]
bot = com.Bot(command_prefix = PREFIXES)
# logging
REPORT_DIR = "logs" # path to log file
REPORT_FILE = "eventLog.txt" # log file
   
# helpers
def senderInfo(ctx: com.Context):
   '''uses the context to return the channel and mention
   of author of the message received.'''
   return (ctx.message.channel, ctx.message.author.mention)

def getReportFile():
   '''concatenates and return the report file path.'''
   return REPORT_DIR + '\\'+ REPORT_FILE

def eReport(report):
   '''uses the logging module to quickly save the report 
   in a file''' 
   # dir doesn't exist
   if not os.path.isdir(REPORT_DIR):
      os.mkdir(REPORT_DIR) # create the folder   
   
   # config logger
   fm = 'a'       # appending by default
   if not os.path.exists(getReportFile()): # file doesn't exist
      fm = "w+"   # then create and append
   logging.basicConfig(filename = getReportFile(),
      format = "%(asctime)s %(process)d %(message)s",
      datefmt = "%d-%b-%y %H:%M:%S", filemode = fm
   )
                        
   # making log object
   logger = logging.getLogger()
   logger.setLevel(logging.DEBUG)
   logger.propagate = False
   
   # log the report
   logger.info(report)

def logError(eData):
   '''logs an error that occured at runtime. "eData" must
   be the tuple generated by sys.exc_info().'''
   eString = eData[0] + '\n' + eData[1]
   print(eString)    # console print it
   eReport(eString)  # report log it 
   # print trace to report file
   print(eData[2], file = getReportFile())

# back end
@bot.event
async def on_ready():
   readyMSG = "We have logged in as {}\n".format(bot.user)
   print(readyMSG)
   # get all guilds
   readyMSG += "online in servers:\n"
   for g in bot.guilds:
      readyMSG += "{}\t".format(g)
   eReport(readyMSG)
   
@bot.event
async def on_command_error(ctx: com.Context, exception):
   '''deal with errors at bot commands execution for
   a smooth runtime.'''
   server = ctx.guild
   triggerUser = ctx.me
   triggerCom = ctx.command
   eReport("error on {} by {} on server {}".format(triggerCom,
      triggerUser, server)) # log trigger info
   logError(exception) # log exception
   await waitThenSend(ctx, "Something went wrong. Sorry, try something else.", 2)

# front end
def buildResponse(ctx: com.Context) -> str:
   '''creates a reply to a hello command by mentionning
   the sender and in a randomly selected formula return
   it to the caller.'''
   hellos = ["Hi", "Oh hello there", "Hiya", "What's up",
      "What's cooking", "Ohayo"
   ]
   return " ".join([rnd.choice(hellos), '{}.'])
   
async def waitThenSend(ctx: com.Context, message: str,
   wait = 1):
   '''sends the passed "message" to the specified channel
   after waiting "wait" seconds.'''
   time.sleep(wait)
   await ctx.reply(message)
      
@bot.command(name = "hello",
   help = "Says hello to the username, using a randomly choosed formula.")
async def hello(ctx):
   '''Says Hi to the username.'''
   # spawn a second thread
   agent = Thread(target = buildResponse,  args =(ctx, ))
   agent.start()  # start it
   agent.join()   # wait for it to finish building message
   channel, mention = senderInfo(ctx)
   await waitThenSend(ctx, buildResponse(ctx).format(mention))

# run module
if __name__ == "__main__":
   # bot runs in try catch to control execution
   try:
      bot.run(os.getenv("BOT_TOKEN"))
   except: # catch any occurence
      logError(sys.exc_info())